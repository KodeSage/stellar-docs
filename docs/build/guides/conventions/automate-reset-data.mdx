---
title: Automating Testnet and Futurenet Reset Data in Stellar
---

<head>
  <title>{`Automating Testnet and Futurenet Reset Data in Stellar`}</title>
  <meta charSet="utf-8" />
  <meta
    property="og:title"
    content="Automating Testnet and Futurenet Reset Data in Stellar"
  />
  <meta
    property="og:description"
    content="Automating Testnet and Futurenet Reset Data in Stellar"
  />
</head>

## Overview

Stellar operates two primary testing environments: the Testnet and the Futurenet. These networks allow developers to experiment with Stellar features without risking real assets. Periodically, these networks are reset to ensure they remain clean and manageable.

## What is the Testnet and Futurenet Reset?

Testnet and Futurenet are reset periodically to the genesis ledger to declutter the network, remove spam, reduce the time needed to catch up on the latest ledger, and help maintain the system. Resets clear all ledger entries (accounts, trustlines, offers, smart contract data, etc.), transactions, and historical data from Stellar Core, Horizon, and the Soroban RPC- which is why developers should not rely on the persistence of accounts or the state of any balances when using Testnet or Futurenet.

## Why Resets are Important?

1. **Clean Slate:** Regular resets ensure that both Testnet and Futurenet provide a clean environment for testing. This helps in avoiding complications arising from old data or configurations.
2. **Performance:** Over time, test environments can accumulate a lot of data, which can slow down performance. Resets help in maintaining optimal performance.
3. **Protocol Updates:** Introducing new features or protocol changes often requires a reset to ensure compatibility and stability.
4. **Development Cycles:** Aligning with development cycles allows developers to plan their testing phases and ensures they have a reliable environment for their work.

## Data Automation on Testnet and Futurenet

Automating data operations on Stellar's Testnet and Futurenet can streamline development workflows, ensuring that you can consistently test and validate your applications in these environments.

### Code Walkthrough

### Prerequisites:

- [Node.js ](https://nodejs.org/en) and npm installed.
- Stellar SDK for [Javascript](https://www.npmjs.com/package/@stellar/stellar-sdk) installed

### Code

```javascript
import * as StellarSdk from "@stellar/stellar-sdk";

async function checkNetworkStatus(server) {
  try {
    const rootInfo = await server.getNetwork();
    console.log("Network status:", rootInfo);
    console.log("Passphrase:", rootInfo.passphrase);
    console.log(" Protocol version:", rootInfo.protocolVersion);
    console.log("FriendBot", rootInfo.friendbotUrl);
    // return rootInfo;
  } catch (error) {
    console.error("Error checking network status:", error);
    throw error;
  }
}
async function createAccount(networkURL) {
  try {
    // Generate a keypair
    const pair = StellarSdk.Keypair.random();
    console.log("Public Key:", pair.publicKey());
    console.log("Secret Key:", pair.secret());
    console.log("Pairs:", pair);

    // Fund the new account using Friendbot
    const response = await fetch(
      `${networkURL}?addr=${encodeURIComponent(pair.publicKey())}`,
    );
    const responseJSON = await response.json();
    console.log("Account created:", responseJSON);

    return pair;
  } catch (error) {
    console.error("Error creating account:", error);
  }
}

async function issueAsset(
  server,
  networkParaphrase,
  SourceKeypair,
  DestinationAccount,
) {
  try {
    const sourceAccount = await server.getAccount(SourceKeypair.publicKey());
    const transaction = new StellarSdk.TransactionBuilder(sourceAccount, {
      fee: StellarSdk.BASE_FEE,
    })
      .setNetworkPassphrase(networkParaphrase)
      .addOperation(
        StellarSdk.Operation.payment({
          destination: DestinationAccount,
          asset: StellarSdk.Asset.native(),
          amount: "20",
        }),
      )
      .addMemo(StellarSdk.Memo.text("PaymentRequest"))
      .setTimeout(30)
      .build();

    console.log(transaction);
    const preparedTransactn = await server.prepareTransaction(transaction);
    preparedTransaction.sign(SourceKeypair);

    server.sendTransaction(transaction).then((result) => {
      console.log("hash:", result.hash);
      console.log("status:", result.status);
      console.log("errorResultXdr:", result.errorResult);
    });
  } catch (e) {
    console.error("An error occurred while issuing assets:", e);
  }
}

async function automateSetup() {
  try {
    // const networkRPC = "USE EITHER FUTERNET OR TESTNET RPC"
    const networkRPC = "https://soroban-testnet.stellar.org";
    // Example
    // FOR FUTERENET - https://rpc-futurenet.stellar.org
    // FOR TESTNET - https://soroban-testnet.stellar.org

    //Initiate Server

    const server = new StellarSdk.SorobanRpc.Server(networkRPC);

    //Check Network Status
    await checkNetworkStatus(server);

    // const networkURL = "USE EITHER FUTERNET OR TESTNET URL"
    const networkURL = "https://friendbot.stellar.org";
    // Example
    // FOR FUTERENET - https://friendbot-futurenet.stellar.org
    // FOR TESTNET - https://friendbot.stellar.org

    const accountOne = await createAccount(networkURL);
    const accountTwo = await createAccount(networkURL);

    // const networkParaphrase = "USE EITHER FUTERNET OR TESTNET Paraphrase"
    const networkParaphrase = StellarSdk.Networks.TESTNET;
    // Example
    // FOR FUTERENET - StellarSdk.Networks.FUTURENET
    // FOR TESTNET -  StellarSdk.Networks.TESTNET

    // Issue assets to these accounts
    await issueAsset(
      server,
      networkParaphrase,
      accountOne,
      accountTwo.publicKey(),
    );
  } catch (error) {
    console.error("An error occurred:", error);
  }
}
automateSetup();
```

The code defines several asynchronous functions:

1. `checkNetworkStatus(server)`:

Retrieves network information using the provided server. Logs network status, passphrase, protocol version, and FriendBot URL. Handles and logs any errors.

2. `createAccount(networkURL)`:

Generates a new Stellar keypair (public and secret keys). Uses FriendBot to fund the new account on the test network. Returns the created keypair.

3. `issueAsset(server, networkParaphrase, SourceKeypair, DestinationAccount)`:

Creates and submits a transaction to issue assets (in this case, 20 units of the native asset) from the source account to the destination account. Adds a memo to the transaction. Signs and sends the transaction, then logs the result.

4. `automateSetup()`:

Sets up the Stellar network connection (using either Futurenet or Testnet). Checks the network status. Creates two new accounts. Issues assets from one account to the other.

### Conclusion

Automating the setup of data on the Stellar Testnet and Futurenet can significantly enhance your development workflow, ensuring that you can quickly return to testing after a network reset. By following the above steps and using the provided code samples, you can streamline your processes and maintain consistency across resets.
